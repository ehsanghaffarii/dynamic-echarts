<!DOCTYPE html>
<title>Radar chart</title>
<meta charset="utf-8" />
<style>
  body,
  html {
    overflow: hidden;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .chart-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
  }
</style>
<div id="chart-wrapper" class="chart-wrapper"></div>
<script
  type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/echarts@5.3.0/dist/echarts.min.js"
></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/4.1.2/papaparse.min.js"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>

<script>
  let state = "notLoaded";
  let datasetUrl = "";
  let source;
  let data;
  let cols;
  let width;
  let height;
  let config = {};
  let option = {};
  let col_rel = {};
  let chartDom;
  let chart;
  let isChartInitialized = false;
  var numericMax = [];
  colorList = [
    "rgb(251, 118, 123)",
    "rgba(0, 215, 239, 1)",
    "rgba(255, 228, 52, 0.6)",
    "#77EADF",
    "#26C3BE",
    "#64AFE9",
    "#428BD4",
  ];
  //
  let develop = false;

  const onWindowResize = () => {
    width = document.documentElement.scrollWidth;
    height = document.documentElement.scrollHeight;
    if (chart)
      chart.resize({
        width: width,
        height: height,
      });
  };

  const onResizeHandler = debounce(onWindowResize, 500);

  window.removeEventListener("resize", onResizeHandler);
  window.addEventListener("resize", onResizeHandler);

  function onMessage(event) {
    if (typeof event?.data == "object") {
      return;
    }
    const allowedOrigins = [
      "http://127.0.0.1:5500",
      "http://localhost:5500",
      "http://127.0.0.1:3000",
      "http://localhost:3000",
      "https://cafedata.io",
      "*",
    ];
    if (!allowedOrigins.includes(event.origin)) {
      console.error(`Invalid origin: ${event.origin}`);
      return;
    }
    try {
      const request = JSON.parse(event.data);
      switch (request.command) {
        case "config_changed":
          update_config_handler(request.config);
          break;
        case "columns_relation_changed":
          col_rel = request.columns_relation;
          if (isChartInitialized) {
            change_col(col_rel);
          }
          break;
        case "data_changed":
          datasetUrl = request.data;
          chart_initial();
          break;
        case "get_state":
          const response = {
            command: "get_state",
            state,
          };
          window.parent.postMessage(JSON.stringify(response), event.origin);
          break;
      }
    } catch (error) {
      console.error(`Invalid request: ${error}`);
      return;
    }
  }

  function main() {
    //todo set col_rel and config
    if (develop) {
      col_rel = {
        name: "Name",
        values: ["Composition", "Voice", "Rhythm", "Solos", "Humour"],
        filter: "Instrument",
        color: "Name",
        facet: "Copyright",
        extra: "Instrument",
      };
      config = {
        chart: {
          background: "#ffffff",
          lineStyle: {
            type: "solid",
            width: "2",
            opacity: "1",
          },
          areaStyle: {
            opacity: "0.1",
          },
          label: {
            show: true,
            fontSize: "12",
            position: "top",
          },
          axisName: {
            color: "#ffffff",
            backgroundColor: "#666666",
            position: "top",
          },
          symbol: "circle",
          radar: {
            shape: "circle",
          },
        },
        title: {
          show: true,
          text: "Customized Radar Chart",
          left: "8%",
          top: "3%",
          color: "#020202",
          fontSize: "18",
        },
        subtext: {
          color: "#020202",
          text: "Source: World Bank",
        },
        tooltip: {
          show: true,
          backgroundColor: "#ffffff",
          borderColor: "#000000",
          borderWidth: 1,
          borderRadius: 10,
          textStyle: {
            color: "#000000",
          },
          formatter: function (params) {
            return params.name + ": " + params.value;
          },
        },
        legend: {
          show: true,
          top: "5%",
          selectedMode: "true",
          data: [],
        },
      };
      chart_initial();
    } else {
      state = "loaded";
      window.parent.document.getElementById("iframe0");
      window.addEventListener("message", onMessage, false);
      window.message = onMessage;
    }
  }

  window.onload = main;

  const chart_initial = async () => {
    try {
      await getCols();
      await handle_data();
      waitUntil(() => {
        onWindowResize();
        if (
          width > 0 &&
          height > 0 &&
          Object.keys(col_rel).length &&
          Object.keys(config).length
        ) {
          if (source?.length) {
            chartDom = document.getElementById("chart-wrapper");
            chart = echarts.init(chartDom);
            init_chart();
            isChartInitialized = true;
          }
          return true;
        }
      });
    } catch (err) {
      console.log("Error :", err);
    }
  };
  ///////////////////////////////////
  ///////////////////////////////////
  ///////////////////////////////////

  // this method is executed when changing the config.

  const updateOptionsStyles = () => {
    const options = {
      backgroundColor: config?.chart?.background,
      title: {
        show: config?.title?.show,
        text: config?.title?.text,
        top: config?.title?.top,
        left: config?.title?.left,
        textStyle: {
          fontSize: config?.title?.fontSize,
          color: config?.title?.color,
        },
        subtextStyle: {
          color: config?.subtext?.color,
          text: config?.subtext?.text,
        },
      },
      legend: {
        show: config?.legend?.show,
        top: config?.legend?.top,
        selectedMode: config?.legend?.selectedMode,
        data: [...cols],
      },
    };
    chart.setOption(options);
    console.log("options", options);
  };

  const init_chart = () => {
    // radar data
    const indicator = [].concat(col_rel.values).map((value) => {
      return {
        text: value,
        max: 12,
      };
    });

    // series data
    const seriesData = [].concat(data).map((value) => {
      return {
        value: (function () {
          const numericValues = [];
          for (let i = 0; i < col_rel.values.length; i++) {
            numericValues.push(value.values[0][col_rel.values[i]]);
            numericMax.push(value.values[0][col_rel.values[i]]);
          }
          return numericValues;
        })(),
        name: value.key,
        lineStyle: {
          type: config?.chart.lineStyle?.type,
          width: config?.chart.lineStyle?.width,
          opacity: config?.chart.lineStyle?.opacity,
        },
        label: {
          show: config?.chart.label?.show,
          fontSize: config?.chart.label?.fontSize,
          position: config?.chart.label?.position,
          formatter: function (params) {
            return params.value;
          },
        },
        areaStyle: {
          color: colorList[Math.floor(Math.random() * colorList.length)],
          opacity: 0.05,
        },
        tooltip: {
          show: config?.chart?.tooltip?.show,
          trigger: "item",
          borderColor: config?.chart?.tooltip?.borderColor,
          backgroundColor: config?.chart?.tooltip?.backgroundColor,
          formatter: function (params) {
            return params.name + ": " + params.value;
          },
        },
      };
    });
    const option = {
      // legend: {
      //   data: [...cols],
      //   selectedMode: config?.legend?.selectedMode,
      // },
      radar: [
        {
          indicator: indicator,
          center: ["50%", "50%"],
          radius: [10, "70%"],

          // this is first radar data indicator: [ {text: ""} ]
          axisName: {
            formatter: function (value, indicator) {
              return `${value}`;
            },
            color: config?.chart?.axisName?.color,
            backgroundColor: config?.chart?.axisName?.backgroundColor,
            borderRadius: 3,
            padding: [3, 5],
          },
          startAngle: 90,
          splitNumber: col_rel.values.length,
          shape: config?.chart?.radar?.shape,
          splitArea: {
            show: false,
          },
          axisLine: {
            show: true,
            lineStyle: {
              type: "solid",
              width: 2,
              opacity: 0.8,
            },
          },
          splitLine: {
            lineStyle: {
              type: "dashed",
              opacity: 0.8,
              width: 2,
              // color: [
              //   "rgba(238, 197, 102, 0.1)",
              //   "rgba(238, 197, 102, 0.2)",
              //   "rgba(238, 197, 102, 0.4)",
              //   // "rgba(238, 197, 102, 0.6)",
              //   // "rgba(238, 197, 102, 0.8)",
              //   // "rgba(238, 197, 102, 1)",
              // ].reverse(),
            },
          },
        },
      ],
      series: [
        {
          data: seriesData,
          type: "radar",
          colorBy: "data",
          symbol: config?.chart?.symbol,
          symbolSize: function (value, indicator) {
            return Math.max(...value);
          },
        },
      ],
    };
    chart.setOption(option);
    updateOptionsStyles();
    console.log(option);
  };
  // this method is executed when changing the data binding.
  const change_col = (cols) => {
    init_chart();
  };

  // this method is executed when changing the config.
  const update_config_handler = (newConfig) => {
    let oldConfig = null;
    if (config) {
      oldConfig = { ...config };
    }
    config = newConfig;

    if (!chart) return;
    // todo update option
    // chart
    updateOptionsStyles();
  };
  // fetch data and convert to standard data chart
  // set data to global state
  //***
  // source = all data
  // col = just col(data[0])
  // data = all data except for col
  //***
  const getCols = async () => {
    return new Promise((resolve, reject) => {
      const _t = setInterval(() => {
        if (Object.keys(col_rel).length) {
          clearInterval(_t);
          resolve(true);
        }
      }, 500);
    });
  };

  const handle_data = async () => {
    try {
      let _data;
      _data = await downloadCsv(datasetUrl);
      const group = d3
        .nest()
        .key(function (d) {
          return d[col_rel?.name];
        })
        .entries(_data)
        .sort(function (a, b) {
          return a.key - b.key;
        })
        .filter((col) => {
          if (col.key !== " " && col.key !== "") {
            return col;
          }
        });
      cols = group.map((col) => col.key);
      source = _data;
      data = group;
    } catch (e) {
      console.log("error in handle data", e);
      return false;
    }
  };

  ////////////// helper
  const waitUntil = (callback) => {
    const _t = setInterval(() => {
      const r = callback();
      if (r === true) {
        clearInterval(_t);
      }
    }, 100);
  };

  function downloadCsv(url) {
    return new Promise((resolve, reject) => {
      // todo
      if (develop) {
        Papa.parse("./data.csv", {
          download: true,
          header: true,
          dynamicTyping: true,
          complete(results, url) {
            resolve(results.data);
          },
          error(err, url) {
            reject(err);
          },
        });
      } else {
        Papa.parse(url, {
          download: true,
          header: true,
          dynamicTyping: true,
          complete(results, url) {
            resolve(results.data);
          },
          error(err, url) {
            reject(err);
          },
        });
      }
    });
  }

  function stringToBoll(_value) {
    if (_value === "true") {
      return true;
    } else {
      return false;
    }
  }

  function debounce(func, wait, immediate) {
    let timeout;
    return function () {
      let context = this,
        args = arguments;
      let later = function () {
        timeout = null;
        if (!immediate) func.apply(context, args);
      };
      let callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
    };
  }
</script>
